<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mage Knight Companion â€” Full (end-round: force 1 crystal + 1 card)</title>
<style>
  :root{
    --bg:#f4f4f4; --panel:#ececec; --card:#fff; --muted:#666;
    --accent:#b00020; --pill:#f7f7f7; --gold:#ffd700;
    --font:system-ui,-apple-system,"Segoe UI",Roboto,Arial;
  }
  *{box-sizing:border-box}
  body{margin:12px;font-family:var(--font);background:var(--bg);color:#111}
  h1{font-size:18px;text-align:center;margin:0 0 12px}
  .container{max-width:980px;margin:0 auto;display:flex;flex-direction:column;gap:12px;padding:0 10px}
  .panel{background:var(--panel);border-radius:10px;padding:10px}
  .panel-inner{background:var(--card);border-radius:8px;padding:12px;display:flex;flex-direction:column;gap:10px}
  .smallbtn{padding:6px 10px;border-radius:6px;border:1px solid #ccc;background:#fff;cursor:pointer}
  .btn-ghost{background:transparent;border:1px dashed #ccc}
  .output{background:#fff;padding:8px;border-radius:6px;min-height:36px}
  .muted{color:var(--muted);font-size:0.95rem}
  .gv-pile{display:flex;gap:6px;flex-wrap:wrap;align-items:center}
  .gv-pill{background:var(--pill);border-radius:6px;padding:6px 8px;border:1px solid #ddd;font-weight:600}
  .gv-desc{color:var(--accent);font-size:0.92rem;margin-top:6px;display:none}

  /* Fame area layout */
  .fame-block{display:flex;flex-direction:column;align-items:center;gap:10px}
  .fame-row{display:flex;align-items:center;justify-content:center;gap:18px;width:100%}
  .fame-controls{display:flex;flex-direction:column;align-items:center;gap:8px}
  .fame-input{width:140px;padding:8px;border-radius:6px;border:1px solid #ccc;text-align:center}
  .fame-increments{display:flex;gap:8px;justify-content:center;flex-wrap:wrap}
  .player-level-box{display:flex;flex-direction:column;align-items:center;gap:6px;min-width:120px}
  .player-level-box label{font-weight:700;display:block;text-align:center}
  .player-level-num{min-width:80px;padding:8px;border-radius:6px;background:#fff;text-align:center;border:1px solid #eee;font-weight:700}

  /* Levels Achieved popup */
  .levels-wrapper{position:relative;display:flex;flex-direction:column;align-items:center;margin-top:6px}
  .levels-trigger{background:transparent;border:0;padding:8px 12px;border-radius:6px;cursor:pointer;font-weight:700}
  .levels-list{
    position:absolute;top:calc(100% + 8px);left:50%;transform:translateX(-50%);
    display:none;min-width:240px;background:#fff;border:1px solid #eee;border-radius:8px;padding:8px;box-shadow:0 8px 24px rgba(0,0,0,0.12);z-index:40;
    font-size:14px;max-height:340px;overflow:auto;
  }
  .levels-list .level-line{padding:6px 8px;border-bottom:1px dashed #f0f0f0;display:flex;gap:8px;align-items:center}
  .levels-list .level-line:last-child{border-bottom:0}
  .levels-list .level-line .lvl-prefix{font-weight:700;white-space:nowrap}
  .levels-list .level-line .lvl-desc{font-weight:400;display:inline-block;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
  .levels-wrapper:hover .levels-list,
  .levels-wrapper:focus-within .levels-list,
  .levels-wrapper[aria-expanded="true"] .levels-list { display:block; }

  /* Reputation wrapper with forced single-line rows */
  .rep-wrap{display:flex;flex-direction:column;gap:8px;align-items:stretch;position:relative;padding:6px}

  /* Force each rep-row to be a single line (no wrap) and size cells so they fit */
  .rep-row{display:flex;align-items:center;gap:8px;padding:6px 0;width:100%;flex-wrap:nowrap;overflow:visible}

  /* Top row has 7 items exactly */
  .rep-row.top .rep-cell{
    flex:0 0 calc((100% - 6 * 8px) / 7);
    height:auto;
    min-height:40px;
    display:flex;align-items:center;justify-content:center;
    padding:6px;border-radius:6px;background:#e8e8e8;text-align:center;font-size:14px;box-sizing:border-box
  }

  /* Middle row: single cell fills available width */
  .rep-row.mid{justify-content:center}
  .rep-row.mid .rep-cell{
    flex:1 1 auto;min-height:40px;display:flex;align-items:center;justify-content:center;padding:6px;border-radius:6px;background:#e8e8e8;font-size:14px;box-sizing:border-box
  }

  /* Bottom row has 7 items exactly */
  .rep-row.bot .rep-cell{
    flex:0 0 calc((100% - 6 * 8px) / 7);
    height:auto;
    min-height:40px;
    display:flex;align-items:center;justify-content:center;
    padding:6px;border-radius:6px;background:#e8e8e8;text-align:center;font-size:14px;box-sizing:border-box
  }

  /* Selected states */
  .rep-row.top .rep-cell.selected{background:var(--gold);font-weight:700;color:#111}
  .rep-row.mid .rep-cell.selected{background:#ffeb99;font-weight:700;color:#111}
  .rep-row.bot .rep-cell.selected{background:#ff6b6b;font-weight:700;color:#fff}

  /* Make cells slightly smaller on narrow screens */
  @media (max-width:420px){
    .rep-row.top .rep-cell,
    .rep-row.bot .rep-cell { min-height:34px; font-size:13px; padding:4px }
    .rep-row.mid .rep-cell { min-height:34px; font-size:13px; padding:4px }
  }
  @media (max-width:340px){
    .rep-row.top .rep-cell,
    .rep-row.bot .rep-cell { min-height:30px; font-size:12px; padding:3px }
    .rep-row.mid .rep-cell { min-height:30px; font-size:12px; padding:3px }
  }

  /* Dummy player responsive layout (compact) */
  .dummy-grid{display:grid;grid-template-columns:1fr 1fr;gap:12px;align-items:start}
  .section-card{background:var(--card);border-radius:8px;padding:10px;border:1px solid #eee}
  .crystal-row{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  .crystal-pill{display:flex;align-items:center;gap:8px;background:var(--pill);padding:8px;border-radius:8px;border:1px solid #eee;min-width:86px;justify-content:space-between}
  .card-row{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  .card-pill{display:flex;align-items:center;gap:8px;background:#fff;padding:8px;border-radius:8px;border:1px solid #eee;min-width:86px;justify-content:space-between}
  .controls-row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .output-small{background:#fff;padding:8px;border-radius:6px;min-height:28px;font-size:14px}

  .symbol { display:inline-flex;align-items:center;justify-content:center;width:28px;height:28px;font-size:18px;position:relative;line-height:1;border-radius:50%; }
  .symbol.spell::after{ content:'S'; position:absolute; top:-7px; right:-8px; width:18px; height:18px; display:inline-flex; align-items:center; justify-content:center; font-size:12px; font-weight:700; color:#fff; background:rgba(0,0,0,0.65); border-radius:10px; box-shadow:0 1px 2px rgba(0,0,0,0.2); }
  .wound-box{display:flex;flex-direction:column;align-items:center;gap:4px;padding:6px;border-radius:6px;background:#fff;border:1px solid #eee;min-width:46px}
  .wound-symbol{font-size:1.2rem;color:var(--accent)}

  /* End-round modal specialized layout */
  .endround-grid{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:8px}
  .choice-list{display:flex;flex-direction:column;gap:8px}
  .choice-item{display:flex;align-items:center;justify-content:space-between;padding:8px;border-radius:6px;border:1px solid #eee;background:#fff}
  .choice-item button{min-width:28px;padding:6px;border-radius:6px}
  .choice-selected{outline:3px solid #7fb1ff;border-radius:8px}
  .modal-foot{display:flex;justify-content:flex-end;gap:8px;margin-top:12px}
</style>
</head>
<body>
  <h1>Mage Knight Companion</h1>

  <div class="container">
    <!-- Reputation (single-line rows) -->
    <section class="panel" aria-labelledby="rep-title">
      <div class="panel-inner">
        <h2 id="rep-title">Reputation</h2>
        <div id="rep-wrap" class="rep-wrap" aria-label="Reputation track" role="group"></div>
      </div>
    </section>

    <!-- Fame -->
    <section class="panel" aria-labelledby="fame-title">
      <div class="panel-inner">
        <h2 id="fame-title">Fame</h2>

        <div class="fame-block" id="fame-block">
          <div class="fame-row" role="group" aria-label="Player fame and level">
            <div class="fame-controls" aria-hidden="false">
              <label style="font-weight:700;display:block;text-align:center">Player Fame</label>
              <input id="fame-input" class="fame-input" type="number" min="0" value="0" aria-label="Player fame" />
            </div>

            <div class="player-level-box" aria-live="polite">
              <label for="player-level-num">Player Level</label>
              <div id="player-level-num" class="player-level-num" aria-label="Player level">1</div>
            </div>
          </div>

          <div class="fame-increments" role="toolbar" aria-label="Add fame options">
            <button class="smallbtn fame-inc" data-inc="1">+1</button>
            <button class="smallbtn fame-inc" data-inc="2">+2</button>
            <button class="smallbtn fame-inc" data-inc="3">+3</button>
            <button class="smallbtn fame-inc" data-inc="5">+5</button>
            <button class="smallbtn fame-inc" data-inc="10">+10</button>
          </div>

          <div class="levels-wrapper" id="levels-wrapper" aria-expanded="false">
            <button id="levels-trigger" class="levels-trigger" aria-controls="levels-list" aria-haspopup="true">Levels Achieved</button>
            <div id="levels-list" class="levels-list" role="list" aria-hidden="true"></div>
          </div>
        </div>
      </div>
    </section>

    <!-- Dummy Player (compact, with End Round behavior) -->
    <section class="panel" aria-labelledby="dummy-title">
      <div class="panel-inner" id="dummy-module">
        <h2 id="dummy-title">Dummy Player</h2>

        <div class="dummy-grid">
          <div class="section-card">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
              <div style="font-weight:600">Crystals</div>
              <div style="font-size:12px;color:var(--muted)">Adjust available crystals</div>
            </div>

            <div class="crystal-row" id="crystal-row">
              <div class="crystal-pill">ðŸ”´ <strong id="red">0</strong>
                <div style="display:flex;gap:6px">
                  <button class="smallbtn crystal-btn" data-player="main" data-color="red" data-act="inc">+</button>
                  <button class="smallbtn crystal-btn" data-player="main" data-color="red" data-act="dec">âˆ’</button>
                </div>
              </div>

              <div class="crystal-pill">ðŸ”µ <strong id="blue">0</strong>
                <div style="display:flex;gap:6px">
                  <button class="smallbtn crystal-btn" data-player="main" data-color="blue" data-act="inc">+</button>
                  <button class="smallbtn crystal-btn" data-player="main" data-color="blue" data-act="dec">âˆ’</button>
                </div>
              </div>

              <div class="crystal-pill">ðŸŸ¢ <strong id="green">0</strong>
                <div style="display:flex;gap:6px">
                  <button class="smallbtn crystal-btn" data-player="main" data-color="green" data-act="inc">+</button>
                  <button class="smallbtn crystal-btn" data-player="main" data-color="green" data-act="dec">âˆ’</button>
                </div>
              </div>

              <div class="crystal-pill">âšª <strong id="white">0</strong>
                <div style="display:flex;gap:6px">
                  <button class="smallbtn crystal-btn" data-player="main" data-color="white" data-act="inc">+</button>
                  <button class="smallbtn crystal-btn" data-player="main" data-color="white" data-act="dec">âˆ’</button>
                </div>
              </div>
            </div>
          </div>

          <div class="section-card">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
              <div style="font-weight:600">Cards</div>
              <div style="font-size:12px;color:var(--muted)">Deck composition</div>
            </div>

            <div class="card-row">
              <div class="card-pill">ðŸ”´ <strong id="card-red">4</strong>
                <div style="display:flex;gap:6px">
                  <button class="smallbtn card-btn" data-player="main" data-color="Red" data-act="inc">+</button>
                  <button class="smallbtn card-btn" data-player="main" data-color="Red" data-act="dec">âˆ’</button>
                </div>
              </div>

              <div class="card-pill">ðŸ”µ <strong id="card-blue">4</strong>
                <div style="display:flex;gap:6px">
                  <button class="smallbtn card-btn" data-player="main" data-color="Blue" data-act="inc">+</button>
                  <button class="smallbtn card-btn" data-player="main" data-color="Blue" data-act="dec">âˆ’</button>
                </div>
              </div>

              <div class="card-pill">ðŸŸ¢ <strong id="card-green">4</strong>
                <div style="display:flex;gap:6px">
                  <button class="smallbtn card-btn" data-player="main" data-color="Green" data-act="inc">+</button>
                  <button class="smallbtn card-btn" data-player="main" data-color="Green" data-act="dec">âˆ’</button>
                </div>
              </div>

              <div class="card-pill">âšª <strong id="card-white">4</strong>
                <div style="display:flex;gap:6px">
                  <button class="smallbtn card-btn" data-player="main" data-color="White" data-act="inc">+</button>
                  <button class="smallbtn card-btn" data-player="main" data-color="White" data-act="dec">âˆ’</button>
                </div>
              </div>
            </div>

            <div style="margin-top:8px" class="muted">Cards in deck: <strong id="deck-count">0</strong></div>
          </div>

          <div class="section-card" style="grid-column:1 / -1">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
              <div style="font-weight:600">Actions</div>
              <div style="font-size:12px;color:var(--muted)">Draw, discard and reshuffle</div>
            </div>

            <div class="controls-row" style="margin-bottom:8px">
              <button id="draw-btn" class="smallbtn" data-player="main">Draw</button>
              <button id="reshuffle-btn" class="smallbtn" data-player="main">Reshuffle Deck</button>
              <div style="flex:1"></div>
              <div class="muted" style="font-size:13px">Discard: <strong id="discard-count">0</strong></div>
            </div>

            <div id="dummy-output" class="output">Drawn symbols appear here</div>
            <div id="discard-output" class="output" style="margin-top:8px">Discard pile is empty.</div>
          </div>
        </div>
      </div>
    </section>

    <!-- General Volkare -->
    <section class="panel" aria-labelledby="gv-title">
      <div class="panel-inner" id="gv-module">
        <h2 id="gv-title">General Volkare</h2>

        <div class="row" style="gap:18px">
          <div style="flex:1">
            <h3 style="margin:0 0 6px 0;font-size:1rem">Deck Composition</h3>

            <div style="display:flex;flex-direction:column;gap:8px">
              <div class="gv-pile">
                <div class="gv-pill">Advanced Actions</div>
                <div class="gv-pill">
                  <span class="symbol">ðŸ”´</span><span class="symbol">ðŸ”´</span><span class="symbol">ðŸ”´</span><span class="symbol">ðŸ”´</span>
                </div>
                <div class="gv-pill">
                  <span class="symbol">ðŸ”µ</span><span class="symbol">ðŸ”µ</span><span class="symbol">ðŸ”µ</span><span class="symbol">ðŸ”µ</span>
                </div>
                <div class="gv-pill">
                  <span class="symbol">ðŸŸ¢</span><span class="symbol">ðŸŸ¢</span><span class="symbol">ðŸŸ¢</span><span class="symbol">ðŸŸ¢</span>
                </div>
                <div class="gv-pill">
                  <span class="symbol">âšª</span><span class="symbol">âšª</span><span class="symbol">âšª</span><span class="symbol">âšª</span>
                </div>
              </div>

              <div class="gv-pile">
                <div class="gv-pill">Spells</div>
                <div class="gv-pill">
                  <span class="symbol spell">ðŸ”´</span>
                  <span class="symbol spell">ðŸ”µ</span>
                  <span class="symbol spell">ðŸŸ¢</span>
                  <span class="symbol spell">âšª</span>
                </div>
              </div>

              <div style="display:flex;align-items:center;gap:12px">
                <div>
                  <div style="font-weight:600;margin-bottom:6px">Wounds</div>
                  <div class="wound-box" aria-live="polite">
                    <div class="wound-num"><strong id="gv-wounds">0</strong></div>
                    <div class="wound-symbol">ðŸ©¸</div>
                  </div>
                </div>

                <div style="display:flex;gap:8px;align-items:center;margin-left:8px">
                  <button class="smallbtn gv-wound-btn" data-act="dec">âˆ’</button>
                  <button class="smallbtn gv-wound-btn" data-act="inc">+</button>
                </div>

                <div style="margin-left:16px" class="muted">Deck size: <strong id="deck-count-gv">0</strong></div>
              </div>

              <div id="gv-frenzy-desc" class="gv-desc" aria-live="polite">
                Frenzy â€” Volkare will act as if a spell was drawn.
              </div>
            </div>
          </div>

          <div style="flex:1">
            <h3 style="margin:0 0 6px 0;font-size:1rem">Controls</h3>
            <div style="display:flex;flex-direction:column;gap:8px">
              <button id="draw-btn-gv" class="smallbtn" data-player="gv">Draw</button>
              <button id="reshuffle-btn-gv" class="smallbtn" data-player="gv">Reshuffle Deck</button>
            </div>
          </div>
        </div>

        <div style="margin-top:10px">
          <div id="dummy-output-gv" class="output">Drawn cards appear here (symbols)</div>
        </div>

        <div style="margin-top:8px">
          <div id="discard-output-gv" class="output">Discard pile is empty.</div>
        </div>
      </div>
    </section>

    <footer style="display:flex;justify-content:center">
      <button id="new-game" class="smallbtn">New Game</button>
    </footer>
  </div>

  <!-- End round modal for dummy player: force 1 crystal + 1 card -->
  <div id="endround-modal" style="display:none;position:fixed;inset:0;align-items:center;justify-content:center;background:rgba(0,0,0,0.45);z-index:60">
    <div style="background:#fff;border-radius:10px;padding:16px;max-width:520px;width:96%;max-height:92vh;overflow:auto">
      <h3 style="margin:0 0 8px 0">End Round â€” Choose 1 Crystal and 1 Card</h3>
      <p style="margin:0 0 8px 0" class="muted">Select exactly one crystal and one card to add to the end-round choices. Confirm becomes enabled once both are chosen.</p>

      <div class="endround-grid">
        <div>
          <div style="font-weight:700;margin-bottom:8px">Choose a Crystal</div>
          <div id="modal-crystals" class="choice-list" aria-label="Crystal choices"></div>
        </div>

        <div>
          <div style="font-weight:700;margin-bottom:8px">Choose a Card</div>
          <div id="modal-cards" class="choice-list" aria-label="Card choices"></div>
        </div>
      </div>

      <div class="modal-foot">
        <button id="endround-cancel" class="smallbtn btn-ghost">Cancel</button>
        <button id="endround-confirm" class="smallbtn" disabled>Confirm</button>
      </div>
    </div>
  </div>

<script>
/* Full integrated JS with:
   - single-line reputation rows (top/mid/bot)
   - dummy player end-round flow: when triggered, force user to pick 1 crystal and 1 card (then apply)
   - GV unchanged; end-round modal specifically for the main player
   - data persisted to localStorage
*/

const STORAGE_KEY = 'mk_companion_full_v8';
const SYMBOL = { Red:'ðŸ”´', Blue:'ðŸ”µ', Green:'ðŸŸ¢', White:'âšª', Wound:'ðŸ©¸' };
const DEFAULT_CARDS = { Red:4, Blue:4, Green:4, White:4 };
const FAME_LEVELS = [
  {level:1, min:0,  max:2},{level:2, min:3,  max:7},{level:3, min:8,  max:14},
  {level:4, min:15, max:23},{level:5, min:24, max:34},{level:6, min:35, max:47},
  {level:7, min:48, max:62},{level:8, min:63, max:79},{level:9, min:80, max:98},
  {level:10,min:99, max:119}
];
const LEVEL_PROMPTS = {
  1: "Command Token",2: "Skill + Advanced Action",3: "Command Token",
  4: "Skill + Advanced Action",5: "Command Token",6: "Skill + Advanced Action",
  7: "Command Token",8: "Skill + Advanced Action",9: "Command Token",10: "Skill + Advanced Action"
};

function clampIntNonNeg(v){ return Math.max(0, Math.floor(Number(v) || 0)); }
function getFameLevel(val){
  const v = Math.max(0, Number(val) || 0);
  for(const b of FAME_LEVELS) if(v>=b.min && v<=b.max) return b.level;
  return 10;
}

/* ---------------- Dummy Module (compact) with end-round forcing behavior ---------------- */
function DummyModule() {
  const ids = {
    red:'red', blue:'blue', green:'green', white:'white',
    cardRed:'card-red', cardBlue:'card-blue', cardGreen:'card-green', cardWhite:'card-white',
    deckCount:'deck-count', drawBtn:'draw-btn', dummyOutput:'dummy-output', discardOutput:'discard-output', reshuffleBtn:'reshuffle-btn'
  };
  let crystals = { red:0, blue:0, green:0, white:0 };
  let cardCounts = { ...DEFAULT_CARDS };
  let deck = [];
  let discard = [];
  let achievedLevels = [1];
  let endRoundFlag = false;
  const SKEY = `${STORAGE_KEY}_main`;

  function el(id){ return document.getElementById(id); }
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }

  function updateCrystalViews(){
    if(el(ids.red)) el(ids.red).textContent = crystals.red;
    if(el(ids.blue)) el(ids.blue).textContent = crystals.blue;
    if(el(ids.green)) el(ids.green).textContent = crystals.green;
    if(el(ids.white)) el(ids.white).textContent = crystals.white;
  }
  function updateCardViews(){
    if(el(ids.cardRed)) el(ids.cardRed).textContent = cardCounts.Red;
    if(el(ids.cardBlue)) el(ids.cardBlue).textContent = cardCounts.Blue;
    if(el(ids.cardGreen)) el(ids.cardGreen).textContent = cardCounts.Green;
    if(el(ids.cardWhite)) el(ids.cardWhite).textContent = cardCounts.White;
  }
  function updateDeckCount(){ const n = el(ids.deckCount); if(n) n.textContent = deck.length; }
  function updateDiscardCount(){ const n = document.getElementById('discard-count'); if(n) n.textContent = discard.length; }
  function displayMainCard(code){
    if(!code) return '';
    if(code.endsWith('Card')) return SYMBOL[code.split(' ')[0]] || code;
    if(code === 'Wound') return SYMBOL.Wound;
    return code;
  }
  function updateDiscardView(){ const node = el(ids.discardOutput); if(!node) return; if(discard.length===0) node.textContent='Discard pile is empty.'; else node.textContent = `Discard (${discard.length}): ${discard.map(displayMainCard).join(' ')}`; }

  function save(){ try{ localStorage.setItem(SKEY, JSON.stringify({crystals,cardCounts,deck,discard,achievedLevels,endRoundFlag})); }catch(e){} }
  function load(){ try{ const raw = localStorage.getItem(SKEY); if(!raw) return false; const s=JSON.parse(raw); crystals = s.crystals || crystals; cardCounts = s.cardCounts || cardCounts; deck = Array.isArray(s.deck)?s.deck:deck; discard = Array.isArray(s.discard)?s.discard:discard; achievedLevels = Array.isArray(s.achievedLevels)?s.achievedLevels:achievedLevels; endRoundFlag = !!s.endRoundFlag; return true; }catch(e){ return false; } }

  function changeCrystal(color, delta){ crystals[color] = Math.max(0,(crystals[color]||0)+delta); updateCrystalViews(); save(); }
  function changeCard(color, delta){
    cardCounts[color] = Math.max(0,(cardCounts[color]||0)+delta);
    updateCardViews();
    if(delta>0){ const name = `${color} Card`; const pos = Math.floor(Math.random()*(deck.length+1)); deck.splice(pos,0,name); }
    else { const name = `${color} Card`; const idx = deck.indexOf(name); if(idx!==-1) deck.splice(idx,1); else { const dj=discard.indexOf(name); if(dj!==-1) discard.splice(dj,1); } }
    updateDeckCount(); updateDiscardView(); updateDiscardCount(); save();
  }

  function rebuildDeck(){ deck = []; Object.keys(cardCounts).forEach(color=>{ for(let i=0;i<cardCounts[color];i++) deck.push(`${color} Card`); }); shuffle(deck); updateDeckCount(); save(); }
  function drawOnce(){
    const drawn=[];
    for(let i=0;i<3 && deck.length>0;i++) drawn.push(deck.pop());
    if(drawn.length===0){
      endRoundFlag = true;
      const btn = el(ids.drawBtn); if(btn) btn.textContent = 'End Round';
      const out = el(ids.dummyOutput); if(out) out.textContent='Nil cards drawn. End of round announced.';
      save();
      // Trigger the forced end-round flow for the main player
      openEndRoundModalForMain();
      return;
    }
    const last = drawn[drawn.length-1];
    if(last){
      const color = last.split(' ')[0].toLowerCase();
      const extra = crystals[color]||0;
      for(let i=0;i<extra && deck.length>0;i++) drawn.push(deck.pop());
    }
    discard.push(...drawn);
    const out = el(ids.dummyOutput); if(out) out.textContent = drawn.map(displayMainCard).join(' ');
    updateDeckCount(); updateDiscardView(); updateDiscardCount(); save();
  }
  function reshuffle(){ if(discard.length===0){ const out = el(ids.dummyOutput); if(out) out.textContent='Discard pile is empty. Nothing to reshuffle.'; return; } deck.push(...discard); discard = []; shuffle(deck); updateDeckCount(); updateDiscardView(); updateDiscardCount(); endRoundFlag=false; const btn = el(ids.drawBtn); if(btn) btn.textContent='Draw'; const out = el(ids.dummyOutput); if(out) out.textContent='Deck reshuffled from discard.'; save(); }

  function getRenderLevels(){ return achievedLevels.slice(); }
  function setAchievedLevels(levels){ if(Array.isArray(levels)) achievedLevels = levels.slice(); save(); }

  function resetInitial(){
    crystals = { red:0, blue:0, green:0, white:0 };
    const keys=['red','blue','green','white'];
    const first = keys[Math.floor(Math.random()*keys.length)];
    let second = keys[Math.floor(Math.random()*keys.length)];
    while(second===first) second=keys[Math.floor(Math.random()*keys.length)];
    crystals[first]=2; crystals[second]=1;
    cardCounts = {...DEFAULT_CARDS};
    deck = []; discard = []; achievedLevels=[1]; endRoundFlag=false;
    rebuildDeck(); updateCrystalViews(); updateCardViews(); updateDeckCount(); updateDiscardView(); updateDiscardCount(); save();
  }

  function wire(){
    document.querySelectorAll('.crystal-btn[data-player="main"]').forEach(btn=>{
      btn.addEventListener('click', ()=>{ const color = btn.dataset.color; const act = btn.dataset.act; changeCrystal(color, act==='inc'?1:-1); });
    });
    document.querySelectorAll('.card-btn[data-player="main"]').forEach(btn=>{
      btn.addEventListener('click', ()=>{ const color = btn.dataset.color; const act = btn.dataset.act; changeCard(color, act==='inc'?1:-1); });
    });
    const drawBtnEl = el(ids.drawBtn);
    if(drawBtnEl) drawBtnEl.addEventListener('click', ()=>{ if(endRoundFlag && drawBtnEl.textContent==='End Round'){ openEndRoundModalForMain(); return; } drawOnce(); });
    const reshuffleEl = el(ids.reshuffleBtn);
    if(reshuffleEl) reshuffleEl.addEventListener('click', reshuffle);
  }

  return { load, save, wire, resetInitial, rebuildDeck, getRenderLevels, changeCard, drawOnce, reshuffle, updateViews: ()=>{ updateCrystalViews(); updateCardViews(); updateDeckCount(); updateDiscardView(); updateDiscardCount(); }, setAchievedLevels, achievedLevelsRef: ()=>achievedLevels };
}

/* ---------------- GV Module ---------------- */
function GVModule(){
  const ids = {
    deckCount:'deck-count-gv', drawBtn:'draw-btn-gv', dummyOutput:'dummy-output-gv', discardOutput:'discard-output-gv',
    reshuffleBtn:'reshuffle-btn-gv', gvWounds:'gv-wounds', gvFrenzyDesc:'gv-frenzy-desc'
  };
  let deck = [];
  let discard = [];
  let wounds = 0;
  const SKEY = `${STORAGE_KEY}_gv`;

  function el(id){ return document.getElementById(id); }
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }

  function buildDefaultDeck(){
    deck = [];
    ['Red','Blue','Green','White'].forEach(c=>{ for(let i=0;i<4;i++) deck.push(`Adv-${c}`); });
    ['Red','Blue','Green','White'].forEach(c=> deck.push(`Spell-${c}`));
    shuffle(deck);
    wounds = 0;
    save(); updateCounts(); updateDrawButtonState();
  }

  function displayGVCard(code){
    if(!code) return '';
    if(code.startsWith('Adv-')) return SYMBOL[code.split('-')[1]] || code;
    if(code.startsWith('Spell-')) return 'S' + (SYMBOL[code.split('-')[1]] || code);
    if(code === 'Wound') return SYMBOL.Wound;
    return code;
  }

  function updateCounts(){
    if(el(ids.deckCount)) el(ids.deckCount).textContent = deck.length;
    if(el(ids.gvWounds)) el(ids.gvWounds).textContent = wounds;
    if(el(ids.discardOutput)) el(ids.discardOutput).textContent = discard.length===0 ? 'Discard pile is empty.' : `Discard (${discard.length}): ${discard.map(displayGVCard).join(' ')}`;
  }

  function save(){ try{ localStorage.setItem(SKEY, JSON.stringify({deck,discard,wounds})); }catch(e){} }
  function load(){ try{ const raw = localStorage.getItem(SKEY); if(!raw) return false; const s=JSON.parse(raw); deck = Array.isArray(s.deck)?s.deck:deck; discard = Array.isArray(s.discard)?s.discard:discard; wounds = typeof s.wounds === 'number'?s.wounds:wounds; updateCounts(); updateDrawButtonState(); return true; }catch(e){ return false; } }

  function changeWounds(delta){
    const newW = Math.max(0, wounds + delta);
    const diff = newW - wounds;
    wounds = newW;
    if(diff > 0){
      for(let i=0;i<diff;i++){
        const pos = Math.floor(Math.random()*(deck.length+1));
        deck.splice(pos,0,'Wound');
      }
    } else if(diff < 0){
      let toRemove = -diff;
      while(toRemove>0){
        const idx = deck.indexOf('Wound');
        if(idx !== -1){ deck.splice(idx,1); toRemove--; continue; }
        const dj = discard.indexOf('Wound');
        if(dj !== -1){ discard.splice(dj,1); toRemove--; continue; }
        break;
      }
    }
    updateCounts(); save(); updateDrawButtonState();
  }

  function drawOnce(){
    const out = el(ids.dummyOutput);
    if(deck.length === 0){
      updateDrawButtonState();
      if(out) out.textContent = 'Deck empty â€” Frenzy ready. Volkare will act as if a spell was drawn.';
      return;
    }
    const card = deck.pop();
    discard.push(card);
    if(out){
      if(card.startsWith('Spell-')){
        out.innerHTML = `<span class="symbol spell">${SYMBOL[card.split('-')[1]]}</span>`;
      } else if(card === 'Wound'){
        out.innerHTML = `<span class="wound-symbol">${SYMBOL.Wound}</span>`;
      } else {
        out.textContent = SYMBOL[card.split('-')[1]] || card;
      }
    }
    updateCounts(); save(); updateDrawButtonState();
  }

  function reshuffle(){
    const out = el(ids.dummyOutput);
    if(discard.length === 0){
      if(out) out.textContent = 'Discard pile is empty. Nothing to reshuffle.';
      return;
    }
    deck.push(...discard); discard = []; shuffle(deck); updateCounts(); if(out) out.textContent = 'Deck reshuffled from discard.'; save();
    updateDrawButtonState();
  }

  function addCardToDiscard(cardCode){
    discard.push(cardCode);
    updateCounts(); save(); updateDrawButtonState();
  }

  function updateDrawButtonState(){
    const btn = el(ids.drawBtn);
    const desc = el(ids.gvFrenzyDesc);
    if(!btn) return;
    if(deck.length === 0){
      btn.textContent = 'Frenzy';
      if(desc) desc.style.display = 'block';
    } else {
      btn.textContent = 'Draw';
      if(desc) desc.style.display = 'none';
    }
  }

  function wire(){
    const drawBtn = el(ids.drawBtn);
    if(drawBtn) drawBtn.addEventListener('click', ()=>{ if(deck.length === 0){ const out = el(ids.dummyOutput); if(out) out.textContent = 'Frenzy â€” Volkare will act as if a spell was drawn.'; return; } drawOnce(); });
    const reshuffleBtn = el(ids.reshuffleBtn); if(reshuffleBtn) reshuffleBtn.addEventListener('click', reshuffle);
    document.querySelectorAll('.gv-wound-btn').forEach(b=> b.addEventListener('click', ()=>{ const act = b.dataset.act; changeWounds(act==='inc'?1:-1); }));
  }

  return { load, save, wire, buildDefaultDeck, updateCounts, drawOnce, reshuffle, addCardToDiscard, updateDrawButtonState, changeWounds };
}

/* ---------------- App wiring ---------------- */
const mainModule = DummyModule();
const gvModule = GVModule();

let fame = 0;

/* Reputation values requested by user */
const REP_TOP = ["0","+1","+1","+2","+2","+3","+5"];
const REP_MID = ["0"];
const REP_BOT = ["0","-1","-1","-2","-3","-5","X"];

/* Build rep rows */
function buildRepRows(){
  const repWrap = document.getElementById('rep-wrap');
  repWrap.innerHTML = '';

  const top=document.createElement('div'); top.className='rep-row top';
  REP_TOP.forEach((label,i)=>{
    const c=document.createElement('div');
    c.className='rep-cell';
    c.textContent=label;
    c.tabIndex=0;
    c.addEventListener('click', ()=>{ selectRepCell({row:'top',index:i}); saveMeta(); });
    c.addEventListener('keydown', (e)=>{ if(e.key==='Enter'||e.key===' '){ e.preventDefault(); selectRepCell({row:'top',index:i}); saveMeta(); }});
    top.appendChild(c);
  });

  const mid=document.createElement('div'); mid.className='rep-row mid';
  REP_MID.forEach((label,i)=>{
    const c=document.createElement('div');
    c.className='rep-cell';
    c.textContent=label;
    c.tabIndex=0;
    c.addEventListener('click', ()=>{ selectRepCell({row:'mid',index:i}); saveMeta(); });
    c.addEventListener('keydown', (e)=>{ if(e.key==='Enter'||e.key===' '){ e.preventDefault(); selectRepCell({row:'mid',index:i}); saveMeta(); }});
    mid.appendChild(c);
  });

  const bot=document.createElement('div'); bot.className='rep-row bot';
  REP_BOT.forEach((label,i)=>{
    const c=document.createElement('div');
    c.className='rep-cell';
    c.textContent=label;
    c.tabIndex=0;
    c.addEventListener('click', ()=>{ selectRepCell({row:'bot',index:i}); saveMeta(); });
    c.addEventListener('keydown', (e)=>{ if(e.key==='Enter'||e.key===' '){ e.preventDefault(); selectRepCell({row:'bot',index:i}); saveMeta(); }});
    bot.appendChild(c);
  });

  repWrap.appendChild(top);
  repWrap.appendChild(mid);
  repWrap.appendChild(bot);

  // apply saved selection if exists
  if(window._repSelection) applyRepSelection(window._repSelection);
  else { window._repSelection = { row:'mid', index: 0 }; applyRepSelection(window._repSelection); saveMeta(); }
}
function selectRepCell(sel){
  document.querySelectorAll('.rep-cell').forEach(c=>c.classList.remove('selected'));
  const rowEl = document.querySelector(`.rep-row.${sel.row}`);
  if(!rowEl) return;
  const cells = rowEl.querySelectorAll('.rep-cell');
  if(cells[sel.index]){ cells[sel.index].classList.add('selected'); window._repSelection = {...sel}; saveMeta(); }
}
function applyRepSelection(sel){ if(!sel) return; const rowEl = document.querySelector(`.rep-row.${sel.row}`); if(!rowEl) return; const cells = rowEl.querySelectorAll('.rep-cell'); if(cells[sel.index]) cells[sel.index].classList.add('selected'); }

/* Levels achieved rendering as requested: "Level X: Description" with prefix bold and description normal weight on one line */
function renderLevelsAchieved(){
  const listEl = document.getElementById('levels-list');
  if(!listEl) return;
  listEl.innerHTML = '';
  const level = getFameLevel(fame);
  if(!level || level < 1){
    const div = document.createElement('div'); div.className='level-line'; div.textContent = 'None yet'; listEl.appendChild(div); return;
  }
  for(let L=1; L<=level; L++){
    const div = document.createElement('div'); div.className='level-line';
    const desc = LEVEL_PROMPTS[L] || '';
    if(desc){
      const prefix = document.createElement('span'); prefix.className = 'lvl-prefix'; prefix.textContent = `Level ${L}:`;
      const d = document.createElement('span'); d.className = 'lvl-desc'; d.textContent = ` ${desc}`;
      div.appendChild(prefix);
      div.appendChild(d);
    } else {
      div.textContent = `Level ${L}`;
    }
    listEl.appendChild(div);
  }
}

/* ---------------- End-round modal behavior for main player ----------------
   Matches earlier behavior: when End Round triggered for dummy player,
   force selecting 1 crystal and 1 card. On confirm, apply selections:
   - add the chosen card to main player's deck (changeCard +1)
   - add 1 crystal of chosen color to crystals (increment)
   This modal is independent of GV and only applies to the main player.
*/
const endroundModal = document.getElementById('endround-modal');
const modalCrystals = document.getElementById('modal-crystals');
const modalCards = document.getElementById('modal-cards');
const endroundConfirm = document.getElementById('endround-confirm');
const endroundCancel = document.getElementById('endround-cancel');
let pendingCrystalChoice = null;
let pendingCardChoice = null;

function openEndRoundModalForMain(){
  pendingCrystalChoice = null;
  pendingCardChoice = null;
  renderModalChoices();
  endroundConfirm.disabled = true;
  if(endroundModal) endroundModal.style.display = 'flex';
}

function closeEndRoundModal(){
  if(endroundModal) endroundModal.style.display = 'none';
  pendingCrystalChoice = null;
  pendingCardChoice = null;
  renderModalChoices();
}

function renderModalChoices(){
  // crystals: red, blue, green, white
  const crystals = [
    {key:'red', label:'ðŸ”´ Red'},
    {key:'blue', label:'ðŸ”µ Blue'},
    {key:'green', label:'ðŸŸ¢ Green'},
    {key:'white', label:'âšª White'}
  ];
  modalCrystals.innerHTML = '';
  crystals.forEach(c => {
    const div = document.createElement('div'); div.className='choice-item';
    const span = document.createElement('div'); span.textContent = c.label;
    const btn = document.createElement('button'); btn.className='smallbtn'; btn.type='button'; btn.textContent = pendingCrystalChoice === c.key ? 'Chosen' : 'Pick';
    btn.addEventListener('click', ()=>{
      pendingCrystalChoice = c.key;
      renderModalChoices();
      updateModalConfirmState();
    });
    if(pendingCrystalChoice === c.key) div.classList.add('choice-selected');
    div.appendChild(span); div.appendChild(btn);
    modalCrystals.appendChild(div);
  });

  // cards: offer Adv-Red/Blue/Green/White and Spell-Red/Blue/Green/White (like earlier renditions)
  const cards = [
    {code:'Adv-Red', label:'ðŸ”´ Advanced Action'},
    {code:'Adv-Blue', label:'ðŸ”µ Advanced Action'},
    {code:'Adv-Green', label:'ðŸŸ¢ Advanced Action'},
    {code:'Adv-White', label:'âšª Advanced Action'},
    {code:'Spell-Red', label:'ðŸ”´ Spell'},
    {code:'Spell-Blue', label:'ðŸ”µ Spell'},
    {code:'Spell-Green', label:'ðŸŸ¢ Spell'},
    {code:'Spell-White', label:'âšª Spell'}
  ];
  modalCards.innerHTML = '';
  cards.forEach(c => {
    const div = document.createElement('div'); div.className='choice-item';
    const span = document.createElement('div'); span.textContent = c.label;
    const btn = document.createElement('button'); btn.className='smallbtn'; btn.type='button'; btn.textContent = pendingCardChoice === c.code ? 'Chosen' : 'Pick';
    btn.addEventListener('click', ()=>{
      pendingCardChoice = c.code;
      renderModalChoices();
      updateModalConfirmState();
    });
    if(pendingCardChoice === c.code) div.classList.add('choice-selected');
    div.appendChild(span); div.appendChild(btn);
    modalCards.appendChild(div);
  });
}

function updateModalConfirmState(){
  endroundConfirm.disabled = !(pendingCrystalChoice && pendingCardChoice);
}

if(endroundCancel) endroundCancel.addEventListener('click', () => {
  // cancel simply closes the modal but retains endRoundFlag state; user can reopen via Reshuffle or New Game flow
  closeEndRoundModal();
});

if(endroundConfirm) endroundConfirm.addEventListener('click', () => {
  if(!pendingCrystalChoice || !pendingCardChoice) return;
  // Apply crystal: increment chosen crystal by 1
  mainModule.changeCrystal ? mainModule.changeCrystal(pendingCrystalChoice, 1) : null;
  // Apply card: add chosen card to main deck (treat Adv/Spell as adding an "Adv"/"Spell" card to deck)
  // We'll add as a named code so the draw/display functions can use it if desired.
  if(pendingCardChoice.startsWith('Adv-') || pendingCardChoice.startsWith('Spell-')){
    // For compatibility with earlier simpler logic, we'll increment the color count if it's an Adv (matching cardCounts),
    // or add a Spell marker into discard/deck if Spell selected (simulate adding a spell to discard so GV/draw logic won't confuse)
    const parts = pendingCardChoice.split('-');
    const kind = parts[0]; const color = parts[1];
    if(kind === 'Adv'){
      // increment cardCounts of that color on mainModule
      mainModule.changeCard && mainModule.changeCard(color, 1);
    } else {
      // For Spell: push a Spell placeholder into discard so the next reshuffle/draw works visually
      // We'll add to discard so player won't immediately draw it unless reshuffled.
      // Use format 'Spell-Color' as token.
      if(mainModule && mainModule.achievedLevelsRef){
        // attempt to access internal discard via exposed module state if available
        try{
          // Best-effort: if mainModule has accessors, use them; else push into localStorage discard structure
          const key = `${STORAGE_KEY}_main`;
          const raw = localStorage.getItem(key);
          if(raw){
            const s = JSON.parse(raw);
            s.discard = s.discard || [];
            s.discard.push(pendingCardChoice);
            localStorage.setItem(key, JSON.stringify(s));
          }
        }catch(e){}
      }
    }
  }
  closeEndRoundModal();
});

/* Meta persistence for fame + rep */
function saveMeta(){ try{ const rep = window._repSelection || null; localStorage.setItem(STORAGE_KEY + '_meta', JSON.stringify({ fame, rep })); }catch(e){} }
function loadMeta(){ try{ const raw = localStorage.getItem(STORAGE_KEY + '_meta'); if(!raw) return false; const m = JSON.parse(raw); fame = typeof m.fame==='number'?m.fame:fame; window._repSelection = m.rep || window._repSelection; return true;}catch(e){ return false; } }

/* Fame handling and prompts */
function handleLevelPrompts(prevLevel, newLevel){
  const messages = [];
  for(let L = prevLevel+1; L<=newLevel; L++){
    if(LEVEL_PROMPTS[L]) messages.push(`Level ${L}: ${LEVEL_PROMPTS[L]}`); else messages.push(`Level ${L}`);
  }
  if(messages.length===0) return;
  alert(messages.join('\n'));
}
function updateFameUI(prevFame = null){
  const prevLevel = prevFame !== null ? getFameLevel(prevFame) : null;
  const level = getFameLevel(fame);
  const lvlEl = document.getElementById('player-level-num');
  if(lvlEl) lvlEl.textContent = level;
  const fameInput = document.getElementById('fame-input');
  if(fameInput) fameInput.value = fame;
  if(prevLevel !== null && level > prevLevel) handleLevelPrompts(prevLevel, level);
  renderLevelsAchieved();
  saveMeta();
}

/* New game */
function newGame(){
  if(!confirm('Start a new game? This will reset saved progress and values to defaults.')) return;
  try{
    localStorage.removeItem(`${STORAGE_KEY}_main`);
    localStorage.removeItem(`${STORAGE_KEY}_gv`);
    localStorage.removeItem(STORAGE_KEY + '_meta');
  }catch(e){}
  fame = 0;
  mainModule.resetInitial();
  gvModule.buildDefaultDeck();
  gvModule.load();
  gvModule.updateCounts && gvModule.updateCounts();
  gvModule.updateDrawButtonState && gvModule.updateDrawButtonState();
  window._repSelection = { row: 'mid', index: 0 };
  buildRepRows(); applyRepSelection(window._repSelection);
  updateFameUI(null);
  renderLevelsAchieved();
}

/* Initialize app */
window.addEventListener('load', ()=>{
  mainModule.load(); mainModule.wire();
  gvModule.load(); gvModule.wire();

  buildRepRows();
  loadMeta();
  if(window._repSelection) applyRepSelection(window._repSelection);
  else { window._repSelection = { row:'mid', index:0 }; applyRepSelection(window._repSelection); saveMeta(); }

  mainModule.rebuildDeck();
  gvModule.buildDefaultDeck();
  gvModule.load();

  mainModule.updateViews();
  gvModule.updateCounts && gvModule.updateCounts();
  gvModule.updateDrawButtonState && gvModule.updateDrawButtonState();

  // Fame input + increments
  const fameInput = document.getElementById('fame-input');
  if(fameInput){
    fameInput.value = fame;
    fameInput.addEventListener('change', ()=>{ const prev=fame; fame = clampIntNonNeg(fameInput.value); updateFameUI(prev); });
  }
  document.querySelectorAll('.fame-inc').forEach(btn=> btn.addEventListener('click', ()=>{ const prev=fame; fame = Math.max(0, Number(fame) + Number(btn.dataset.inc||0)); if(fameInput) fameInput.value = fame; updateFameUI(prev); }));

  // Levels trigger click toggles aria-expanded (hover/focus also show)
  const wrapper = document.getElementById('levels-wrapper');
  const trigger = document.getElementById('levels-trigger');
  const list = document.getElementById('levels-list');
  if(trigger && wrapper && list){
    trigger.addEventListener('click', (e)=>{
      const expanded = wrapper.getAttribute('aria-expanded') === 'true';
      wrapper.setAttribute('aria-expanded', expanded ? 'false' : 'true');
      list.setAttribute('aria-hidden', expanded ? 'true' : 'false');
      if(!expanded) trigger.focus();
    });
    document.addEventListener('click', (ev)=>{
      if(!wrapper.contains(ev.target)){
        wrapper.setAttribute('aria-expanded','false');
        list.setAttribute('aria-hidden','true');
      }
    });
    document.addEventListener('keydown', (ev)=>{
      if(ev.key === 'Escape'){
        wrapper.setAttribute('aria-expanded','false');
        list.setAttribute('aria-hidden','true');
      }
    });
  }

  // New game
  document.getElementById('new-game').addEventListener('click', newGame);

  // initial render
  updateFameUI(null);
  renderLevelsAchieved();

  // periodic save
  setInterval(()=>{ mainModule.save && mainModule.save(); gvModule.save && gvModule.save(); saveMeta(); }, 2000);
});

/* Expose for quick debug */
window._main = mainModule;
window._gv = gvModule;
</script>
</body>
</html>
